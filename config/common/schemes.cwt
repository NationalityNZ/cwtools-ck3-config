types = {
    type[scheme] = {
        path = "game/common/schemes"
        localisation = {
            ## primary
            name = "$"
            action = "$_action"
        }
        modifiers = {
            "max_$_schemes_add" = int_value_field
            "$_power_add" = value_field
            "$_power_mult" = int_value_field
            "$_resistance_add" = value_field
            "$_resistance_mult" = int_value_field
        }
    }
}

scheme = {
    ### Skill to base the scheme on.
    skill = enum[attribute]

    desc = localisation

    icon = scalar

    ## cardinality = 0..1
    ### Defaults to `no`. Hostile schemes are affected my hostile scheme modifiers, other schemes are personal and thus affected by personal scheme modifiers.
    hostile = bool

    ### Can be started or not.
    allow = single_alias_right[trigger_clause]

    ### What conditions have to be fulfilled for the scheme to keep going; if invalid it will end. Checked daily.
    valid = single_alias_right[trigger_clause]

    ## cardinality = 0..1
    ### How much does the AI have to want to join in order to actually join
    agent_join_threshold = int

    ## cardinality = 0..1
    ### If the AI falls below this, it will automatically leave the scheme
    agent_leave_threshold = int

    ## cardinality = 0..1
    ### If set to no, it is not possible to add agents to this scheme in any way. The member list and invite button will also get hidden
    uses_agents = bool

    ## cardinality = 0..1
    ### if set to no, this makes resistance be 0
    uses_resistance = bool

    ## cardinality = 0..1
    ### trigger to check if an agent is valid to be part of the scheme (some basic checks already apply, use sparingly as this is checked frequently)
    valid_agent = single_alias_right[trigger_clause]

    ## cardinality = 0..1
    ### How much does the AI want to join
    agent_join_chance = single_alias_right[chance_block]

    ## cardinality = 0..1
    ### each agent adds this to the success chance of the scheme uses the same scopes as the join chance (agent as root)
    agent_success_chance = single_alias_right[chance_block]

    ## cardinality = 0..1
    ### the base chance uses the scheme as root
    base_success_chance = single_alias_right[chance_block]

    # All fields here only use integers in vanilla files, but perhaps values could be used?
    # Badly documented as `maximum_success_chance`.
    ## cardinality = 0..1
    ### Defaults to `100`. (?)
    maximum_success = int[0..100]

    ## cardinality = 0..1
    ### Defaults to `0`. (?)
    minimum_success = int[0..100]

    ## cardinality = 0..1
    ### Defaults to `100`. (?)
    maximum_secrecy = int[0..100]
    
    ## cardinality = 0..1
    ### Defaults to `0`. (?)
    minimum_secrecy = int[0..100]

    ## cardinality = 0..1
    ### Defaults to `100`. (?)
    maximum_progress_chance = int[0..100]

    ## cardinality = 0..1
    ### Defaults to `5`. (?)
    minimum_progress_chance = int[0..100]

    ### After the scheme ends, how many days minimum before the same type of scheme can be used by the owner on the target
    ## cardinality = 0..1
    cooldown = {
        enum[duration] = int
    }

    ## cardinality = 0..1
    ### If the Scheme is secret, the secrecy mechanics are used (otherwise always 100% secrecy)
    is_secret = bool

    ## cardinality = 0..1
    ### trigger that can be used for schemes that sometimes should be secret and sometimes not (seduction depending on targets) if this returns false secrecy is set to 100%
    use_secrecy = single_alias_right[trigger_clause]

    ## cardinality = 0..1
    ### The base chance used for the monthly scheme expose check secrecy is based on: base_secrecy + success_chance + scheme_modifiers and clamped to 0-100
    base_secrecy = int

    ### What happens when scheme reaches full progress.
    ## What should happen when the scheme is ready (ie when progress has reached it's maximum)
    on_ready = single_alias_right[effect_clause]

    # Potentially optional? All vanilla schemes have this.
    ### What happens every month the scheme is active.
    on_monthly = single_alias_right[effect_clause]

    ### What happens when scheme is invalidated (based on `valid` trigger).
    on_invalidated = single_alias_right[effect_clause]

    ### effect executed for every agent that joins. If not empty, it replacec default feed notifications about joining agents
    ## cardinality = 0..1
    on_agent_leave = single_alias_right[effect_clause]

    ### effect executed for every agent that leaves the scheme. If not empty, it replace default feed notifications about leaving agents. Doesn't get triggered for invalidated scheme
    ## cardinality = 0..1
	on_agent_join = single_alias_right[effect_clause]

    # Travel freeze/cancel defaults to no.
    ### If the scheme should freeze automatically when the schemer starts traveling
    ## cardinality = 0..1
	freeze_scheme_when_traveling = bool 
    ### If the scheme should freeze automatically when the scheme target starts traveling
	## cardinality = 0..1
    freeze_scheme_when_traveling_target = bool 
    ### If the scheme should be cancelled automatically when the schemer starts traveling
	## cardinality = 0..1
    cancel_scheme_when_traveling = bool 
    ### If the scheme should be cancelled automatically when the scheme target starts traveling
	## cardinality = 0..1
    cancel_scheme_when_traveling_target = bool 

    # Potentially optional?
    ### Each skill points add this much power (speed) to the scheme.
    power_per_skill_point = float

    # Potentially optional?
    ### Each skill point of the target adds this much resistance.
    resistance_per_skill_point = float

    ## cardinality = 0..1
    power_per_agent_skill_point = float

    # Vanilla murder scheme does not have the following two, so optional.
    ## cardinality = 0..1
    ### Defaults to `1`. Schemes not using this should set to `0`.
    spymaster_power_per_skill_point = float

    ## cardinality = 0..1
    spymaster_resistance_per_skill_point = float

    # Never used in vanilla.
    ## cardinality = 0..1
    ### Defaults to `1`.
    tier_resistance = int

    # Not documented in .info, present in vanilla files.
    ### What the game tells the player happens when successful.
    success_desc = localisation

    ## cardinality = 0..1
    ### What the game tells the player happens when discovered.
    discovery_desc = localisation
}